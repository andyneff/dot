#!/usr/bin/env false bash

: ${DOT_BACKUP_DIR="${SCRIPT_DIR}/bak"}

# SSH auto gen defaults
# Name of ssh-keygen executable, in case you want to customize it. Set to empty
# string to disable auto generating an ssh key
: ${DOT_GIT_SSH_KEY_GEN=ssh-keygen}
# The type of ssh key that is generate
: ${DOT_GIT_SSH_KEY_TYPE=rsa}
# The location to store the ssh key
: ${DOT_GIT_SERVER_SSH_KEY=~/.ssh/id_${DOT_GIT_SSH_KEY_TYPE}}

# If this array is not set in any other dot.env in dot_repos...
if ! declare -p DOT_GIT_SSH_KEY_OTHER_ARGS; then
  # Set additional arguments to pass to ssh-keygen. This is a good default, and
  # even works on ed25519 because ed25519 ignores the -b flag
  DOT_GIT_SSH_KEY_OTHER_ARGS=(-b 4096)
fi

function symlink()
{
  # $1 Source file
  # $2 target symlink name
  if [ "${OS-}" = "Windows_NT" ] && [ -z "${FORCE_LN+set}" ]; then
    cmd //c mklink "$(cygpath -w "${2}")" "$(cygpath -w "${1}")"
  else
    ln -s "${1}" "${2}"
  fi
}

source "${SCRIPT_DIR}/external/vsi_common/linux/string_tools.bsh"

function add_after_if()
{
  # $1 filename
  # $2 line to add $3 after
  # $3 string

  if ! grep -q "${3}" "${1}" &> /dev/null; then
    local before_line="^$(regex_escape "${2}")"
    add_if "${1}" "${before_line}" "${2}"
    sed -i "s|${before_line}.*|&\n${3}|" "${1}"
  fi
}

function add_if()
{
  # $1 filename
  # $2 grep pattern (null string for always)
  # $3 string

  if [ "${2}" = "" ] || ! grep -q "${2}" "${1}" &> /dev/null; then
    if [ -s "${1}" ]; then
      # append to end of the file, always makes it its own line, and always
      # ends with a newline
      sed -i '$r/dev/stdin' "${1}" <<< "${3}"
    else
      # Sed doesn't work on empty files
      echo "${3}" > "${1}"
    fi
  fi
}

function backup_and_replace()
{
  local new_file="${1}"
  local target="${2}"
  local backup_file="${3}"

  # stash old dotfiles
  if [ -e "${target}" ]; then
    if [ ! -e "${backup_file}" ] && [ ! -L "${target}" ]; then
      mkdir -p "$(dirname "${backup_file}")"
      mv "${target}" "${backup_file}"
    else
      rm "${target}"
    fi
  fi

  mkdir -p "$(dirname "${target}")"

  # create new symbolic links
  symlink "${new_file}" "${target}"
}
